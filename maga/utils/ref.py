from typing import Any, Sequence
from libs.utils.universaltype import UniversalType

# WARNING
# small amount of the following code are generated by llms 
# i am simply too lazy to write them by myself

class TempList(list):
    def __init__(self, as_type=list):
        super().__init__([])
        self.as_type = as_type

def make_temp(value):
    target_type = UniversalType.get_int(value)
    match target_type:
        case 1:
            return TempList(list)
        case 2:
            return TempList(tuple)
        case 3:
            return TempList(set)
        case 4:
            return TempList(dict)
        case _:
            return value

class Ref:
    def __init__(self, root: Any, indices: Sequence[int | Any] = ()):
        self.root = root
        self.prev_root = root
        self.indices = tuple(indices)
        self.indices_ids = {}
        self.id = None
        self.prev_id = None

        self.array_map = {}

    def get(self):
        if self.id == self.prev_id:
            return self.prev_root

        value = self.root
        if self.id is not None:
            self.prev_id = self.id
            if self.id in self.array_map:
                value = self.array_map[self.id]
                self.prev_root = value
                return value
            else:
                if self.id in self.indices_ids:
                    root, nav = (self.indices_ids[self.id] + (None, None))[:2]
                    value = self.array_map[root][nav] if nav is not None else value[root]
                    self.array_map[self.id] = value
                    self.prev_root = value
                    return value
                
                for idx in self.indices:
                    value = value[idx]
                self.array_map[self.id] = value
        else:
            for idx in self.indices:
                value = value[idx]
        self.prev_root = value
        return value

    def append(self, value):
        value = make_temp(value)
        self.get().append(value)
        return self.root

    def __getitem__(self, key):
        return Ref(self.root, self.indices + [key])

    def __len__(self):
        return len(self.get())

    def __iter__(self):
        return iter(self.get())

    def __contains__(self, item):
        return item in self.get()

    def __repr__(self):
        try:
            val = self.get()
        except Exception:
            val = "<invalid>"
        return f"<Ref {self.indices} -> {val!r}>"

    def final(self):
        def _convert(value):
            if type(value) is TempList:
                converted = [_convert(v) for v in value]

                target_type = UniversalType.get_int(value.as_type)
                match target_type:
                    case 1:
                        return converted
                    case 2:
                        return tuple(converted)
                    case 3:
                        return set(converted)
                    case 4:
                        it = iter(converted)
                        return dict(zip(it, it))
                    case _:
                        raise TypeError(f"Unknown as_type {value.as_type}")
            else:
                return value

        return _convert(self.root)
