from typing import Any, Sequence

# WARNING
# the some of the following code are generated by llms 
# i am simply too lazy to write them by myself

class TempList(list):
    def __init__(self, data=None, as_type=list):
        super().__init__(data or [])
        self.as_type = as_type

def make_temp(value):
    match value:
        case list():
            return TempList(value, as_type=list)
        case tuple():
            return TempList(list(value), as_type=tuple)
        case set():
            return TempList(list(value), as_type=set)
        case dict():
            return TempList(list(value.items()), as_type=dict)
    return value

class Ref:
    def __init__(self, root: Any, indices: Sequence[int | Any] = ()):
        self.root = root
        self.indices = tuple(indices)

    def get(self):
        value = self.root
        for idx in self.indices:
            value = value[idx]
        return value

    def _set_in_container(self, container, key, value):
        if isinstance(container, Ref):
            container = container.get()

        if isinstance(container, (list, TempList)):
            container[key] = value
            return container
        elif isinstance(container, tuple):
            return container[:key] + (value,) + container[key + 1:]
        elif isinstance(container, dict):
            container[key] = value
            return container
        else:
            raise TypeError(f"Unsupported container type: {type(container)}")

    def set(self, value):
        if not self.indices:
            self.root = value
            return self.root

        parent_ref = Ref(self.root, self.indices[:-1])
        parent = parent_ref.get()
        key = self.indices[-1]

        new_parent = self._set_in_container(parent, key, value)
        if isinstance(parent, tuple):
            return parent_ref.set(new_parent)
        else:
            return self.root

    def append(self, value):
        target = self.get()
        value = make_temp(value)

        match target:
            case TempList():
                target.append(value)
            case list():
                target.append(value)
            case tuple():
                new_list = make_temp(target)
                new_list.append(value)
                self.set(new_list)
            case set():
                new_list = make_temp(target)
                new_list.append(value)
                self.set(new_list)
            case dict():
                temp_list = make_temp(list(target.items()))
                temp_list.append(value)
                self.set(temp_list)
            case _:
                raise TypeError(f"Cannot append to type {type(target)}")

        return self.root

    def __getitem__(self, key):
        return Ref(self.root, self.indices + [key])

    def __len__(self):
        return len(self.get())

    def __iter__(self):
        return iter(self.get())

    def __contains__(self, item):
        return item in self.get()

    def __repr__(self):
        try:
            val = self.get()
        except Exception:
            val = "<invalid>"
        return f"<Ref {self.indices} -> {val!r}>"

    def final(self):
        def _convert(value):
            if isinstance(value, TempList):
                converted = [_convert(v) for v in value]

                if value.as_type is list:
                    return converted
                elif value.as_type is set:
                    return set(converted)
                elif value.as_type is tuple:
                    return tuple(converted)
                elif value.as_type is dict:
                    it = iter(converted)
                    return dict(zip(it, it))
                else:
                    raise TypeError(f"Unknown as_type {value.as_type}")
            else:
                return value

        return _convert(self.root)
