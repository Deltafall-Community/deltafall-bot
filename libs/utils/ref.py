from typing import Any, Sequence

# WARNING
# the some of the following code are generated by llms 
# i am simply too lazy to write them by myself

class TempList(list):
    def __init__(self, data=None, as_type=list):
        super().__init__(data or [])
        self.as_type = as_type

def make_temp(value):
    if type(value) is list:
        return TempList(value, as_type=list)
    elif type(value) is tuple:
        return TempList(list(value), as_type=tuple)
    elif type(value) is set:
        return TempList(list(value), as_type=set)
    elif type(value) is dict:
        return TempList(list(value.items()), as_type=dict)
    return value

class Ref:
    def __init__(self, root: Any, indices: Sequence[int | Any] = ()):
        self.root = root
        self.indices = tuple(indices)
        self.indices_ids = {}
        self.id = None

        self.array_map = {}

    def get(self):
        value = self.root
        if self.id is not None:
            if (am := self.array_map.get(self.id)):
                return am
            else:
                if (im := self.indices_ids.get(self.id)):
                    if (am := self.array_map.get(im[0])):
                        if len(im) > 1:
                            value = am[im[1]]
                        else:
                            value = value[im[0]]
                        self.array_map[self.id] = value
                        return value
                
                for idx in self.indices:
                    value = value[idx]
                self.array_map[self.id] = value
        else:
            for idx in self.indices:
                value = value[idx]
        
        return value

    def _set_in_container(self, container, key, value):
        if isinstance(container, Ref):
            container = container.get()

        if isinstance(container, (list, TempList)):
            container[key] = value
            return container
        elif isinstance(container, tuple):
            return container[:key] + (value,) + container[key + 1:]
        elif isinstance(container, dict):
            container[key] = value
            return container
        else:
            raise TypeError(f"Unsupported container type: {type(container)}")

    def set(self, value):
        if not self.indices:
            self.root = value
            return self.root

        parent_ref = Ref(self.root, self.indices[:-1])
        parent = parent_ref.get()
        key = self.indices[-1]

        new_parent = self._set_in_container(parent, key, value)
        if isinstance(parent, tuple):
            return parent_ref.set(new_parent)
        else:
            return self.root

    def append(self, value):
        target = self.get()
        value = make_temp(value)

        if type(target) is TempList:    
            target.append(value)
        elif type(target) is list:
            target.append(value)
        elif type(target) is tuple:
            new_list = make_temp(target)
            new_list.append(value)
            self.set(new_list)
        elif type(target) is set:
            new_list = make_temp(target)
            new_list.append(value)
            self.set(new_list)
        elif type(target) is dict:
            temp_list = make_temp(list(target.items()))
            temp_list.append(value)
            self.set(temp_list)
        else:    
            raise TypeError(f"Cannot append to type {type(target)}")

        return self.root

    def __getitem__(self, key):
        return Ref(self.root, self.indices + [key])

    def __len__(self):
        return len(self.get())

    def __iter__(self):
        return iter(self.get())

    def __contains__(self, item):
        return item in self.get()

    def __repr__(self):
        try:
            val = self.get()
        except Exception:
            val = "<invalid>"
        return f"<Ref {self.indices} -> {val!r}>"

    def final(self):
        def _convert(value):
            if type(value) is TempList:
                converted = [_convert(v) for v in value]

                if value.as_type is list:
                    return converted
                elif value.as_type is set:
                    return set(converted)
                elif value.as_type is tuple:
                    return tuple(converted)
                elif value.as_type is dict:
                    it = iter(converted)
                    return dict(zip(it, it))
                else:
                    raise TypeError(f"Unknown as_type {value.as_type}")
            else:
                return value

        return _convert(self.root)
