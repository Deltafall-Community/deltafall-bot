from typing import Any, Sequence

# WARNING
# the following code are generated by llms
# i am simply too lazy to write them by myself

class TempList(list):
    """A mutable list wrapper that remembers what type it should become."""
    def __init__(self, data=None, as_type=list):
        super().__init__(data or [])
        self.as_type = as_type

def make_temp(value):
    """Convert immutable containers to mutable TempList or dict recursively."""
    if isinstance(value, TempList):
        return value
    elif isinstance(value, list):
        return TempList(value, as_type=list)
    elif isinstance(value, tuple):
        return TempList(list(value), as_type=tuple)
    elif isinstance(value, set):
        return TempList(list(value), as_type=set)
    elif isinstance(value, dict):
        # convert dict values recursively, store as TempList for building
        return TempList(list(value.items()), as_type=dict)
    else:
        return value

class Ref:
    def __init__(self, root: Any, indices: Sequence[int | Any] = ()):
        self.root = root
        self.indices = list(indices)

    def get(self):
        value = self.root
        for idx in self.indices:
            value = value[idx]
        return value

    def _set_in_container(self, container, key, value):
        if isinstance(container, Ref):
            container = container.get()

        if isinstance(container, (list, TempList)):
            container[key] = value
            return container
        elif isinstance(container, tuple):
            return container[:key] + (value,) + container[key + 1:]
        elif isinstance(container, dict):
            container[key] = value
            return container
        else:
            raise TypeError(f"Unsupported container type: {type(container)}")

    def set(self, value):
        if not self.indices:
            self.root = value
            return self.root

        parent_ref = Ref(self.root, self.indices[:-1])
        parent = parent_ref.get()
        key = self.indices[-1]

        new_parent = self._set_in_container(parent, key, value)
        if isinstance(parent, tuple):
            return parent_ref.set(new_parent)
        else:
            return self.root

    # --- append / add / modify ---
    def append(self, value):
        target = self.get()

        # auto-wrap containers
        value = make_temp(value)

        if isinstance(target, (list, TempList)):
            target.append(value)

        elif isinstance(target, tuple):
            new_list = make_temp(target)
            new_list.append(value)
            self.set(new_list)

        elif isinstance(target, set):
            new_list = make_temp(target)
            new_list.append(value)
            self.set(new_list)

        elif isinstance(target, dict):
            # dict building uses TempList for append
            temp_list = make_temp(list(target.items()))
            temp_list.append(value)
            self.set(temp_list)

        else:
            raise TypeError(f"Cannot append to type {type(target)}")

        return self.root

    def __getitem__(self, key):
        return Ref(self.root, self.indices + [key])

    def __len__(self):
        return len(self.get())

    def __iter__(self):
        return iter(self.get())

    def __contains__(self, item):
        return item in self.get()

    def __repr__(self):
        try:
            val = self.get()
        except Exception:
            val = "<invalid>"
        return f"<Ref {self.indices} -> {val!r}>"

    def final(self):
        """Recursively convert TempLists back to intended types."""
        def _convert(value):
            if isinstance(value, TempList):
                converted = [_convert(v) for v in value]

                if value.as_type is set:
                    return set(converted)
                elif value.as_type is tuple:
                    return tuple(converted)
                elif value.as_type is list:
                    return list(converted)
                elif value.as_type is dict:
                    # convert flat list to dict: every 2 items = key/value
                    it = iter(converted)
                    return dict(zip(it, it))
                else:
                    raise TypeError(f"Unknown as_type {value.as_type}")

            elif isinstance(value, list):
                return [_convert(v) for v in value]
            elif isinstance(value, dict):
                # dict values stored as list of pairs during build
                it = iter(value.items())
                return dict((k, _convert(v)) for k, v in it)
            elif isinstance(value, set):
                return {_convert(v) for v in value}
            elif isinstance(value, tuple):
                return tuple(_convert(v) for v in value)
            else:
                return value

        return _convert(self.root)
